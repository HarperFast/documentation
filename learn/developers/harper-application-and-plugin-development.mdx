---
title: Harper Applications in Depth
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import HarperArchitectureDiagram from '../../src/components/learn/harper-architecture-diagram.mdx';

In the Getting Started guides you successfully installed Harper and created your first application. You experienced Harper's schema and database system, and the automatic REST API feature too. This guide dives deeper into Harper's Component Architecture differentiating applications from plugins, and introduces multiple new ways to interact with Harper. By the end of this guide you will be a confident Harper application developer capable of creating just about anything with Harper!

## What You Will Learn

- The fundamental concepts and architecture of Harper Applications
- How applications and plugins work together in the Harper ecosystem
- The distinction between applications and plugins, and when to use each
- How to interact with Harper using the Operations API and CLI
- Essential debugging techniques for Harper application development
- Best practices for structuring and developing Harper applications

## Prerequisites

- Completed [Install and Connect Harper](../getting-started/install-and-connect-harper)
- Completed [Create Your First Application](../getting-started/create-your-first-application)
- Basic familiarity with Node.js and JavaScript
- Working Harper installation (local or Fabric)

## Revisiting Harper's Architecture

In the previous guide we introduced a high-level Harper architecture diagram:

<HarperArchitectureDiagram />

And defined some key Harper concepts:

**Components** are extensions of the core Harper systems, and are further classified as **plugins** and **applications**.

**Plugins** have access to APIs exposing many of Harper's core services, and are capable of implementing more advanced features than what the core services provide.

**Applications** use plugins to implement user-facing functionality and business logic, such as implementing database schemas and creating web applications.

The most important thing to remember is that plugins enable the functionality and applications implement it. Similar to that of a front-end framework. React is like a plugin; on its own it doesn't actually do anything. You actually need to build an application with React for it do anything meaningful.

Plugins have replaced an old Harper component system called **extensions**. Plugins and extensions have essentially the same definition, but different APIs. In time, extensions will be deprecated, and we encourage all developers to use the plugins immediately. However, both systems are fully supported in Harper v4 and v5.

### The Harper Stack in Detail

Harper itself is a Node.js application. It runs in a single process, and uses worker threads for parallelization. Harper is meant to be a long-running process. Harper instances are meant to be treated as "serverful" systems (contrary to ephemeral "serverless" services). As such, Harper's main thread is meant to always stay running. The concept of a "restart" is specific to restarting the worker threads, and persisting the main thread. Harper uses a rolling restart in order to ensure the Harper system remains functional throughout a restart. Furthermore, the entire Harper process can be safely stopped and started, but generally that should be unnecessary for application development.

:::note
Harper provides an environment variable, `HARPER_EXIT_ON_RESTART`, that will exit the process when it is instructed to restart. This is meant to be used along side a container environment restart policy such as docker's `--restart=unless-stopped` so that the entire Harper process can be restarted. Its important to keep in mind that full process restarts will disrupt functionality.
:::

Plugins run exclusively on worker threads, but the older version, extensions, can run on both the main and worker threads. Some of Harper's core services, such as the database and the networking socket router, are implemented directly within the main process. However, a majority of Harper's core functionality is implemented as built-in plugins and extensions. One critical advantage that plugins have over extensions is their ability to respond to configuration changes without restarting.

Both the `graphqlSchema` database schema system and the `rest` automatic REST API features from the previous guide are technically implemented as built-in extensions still. If you were running Harper locally, the `harper dev` command automatically restarted Harper for you. And if you were using Fabric, this is why you had to click on the "Restart Cluster" button. We are actively migrating all built-in extensions to the plugin API, and once complete, a lot of Harper will run entirely in worker threads and require less restarts in order to respond to configuration and file changes. Aside from the subtle differences in execution context, extensions and plugins very much serve the same purpose. Aside from this section where we are deliberately specifying the technical differences between the two, we have switched to using the plugin terminology entirely. This is to simplify and align our documentation to Harpers ideal future.

Since core services and plugins are the building blocks of applications, they too can run across all threads. As an application developer, you don't necessarily need to worry to much about what plugins are doing behind the scenes; however, its important to keep in mind that for now, restarting Harper is an important step throughout application development, deployment, and management. Later in this guide you will learn other methods for restarting Harper beyond just the `dev` command.

### Component Classification: Built-in vs Custom

Harper further classifies components (plugins and applications) as either built-in or custom. **Built-in** components are internal to Harper, require no additional installation steps, and are immediately accessible for use. The `graphqlSchema` and `rest` plugins are great examples of built-in plugins. **Custom** components are external to Harper, generally available as an npm package or git repository, and do require additional installation steps in order to be used. Custom components can be authored by anyone, including Harper. Any of Harper's official custom components are published using the `@harperdb` and `@harper` package scopes, such as the [`@harperdb/nextjs`](https://github.com/HarperDB/nextjs) plugin for developing Next.js applications or the [`@harperdb/status-check`](https://github.com/HarperDB/status-check) application.

Harper's reference documentation contains detailed documentation for all built-in components. Custom components will be documented within their respective repositories.

Harper does not currently include any built-in applications, making "custom applications" a bit redundant. Generally, we just refer to them as "applications". However, there is a multitude of both built-in and custom plugins, and so the documentation tends to specify whenever relevant.

## Working with the Operations API

In the first guide, we introduced you to the `/health` endpoint. This is provided by Harper's built-in Operations API.

The **Operations API** provides a full set of capabilities for configuring, deploying, administering, and controlling Harper. It is configured on port `9925` by default, and primarily functions through JSON-based, POST requests to the root path `/`. It has some additional functionalities too such as the `/health` endpoint and an OpenAPI endpoint `/api/openapi/rest`.

The operations API root path POST requests must be authenticated. Harper provides an `authentication.authorizeLocal` configuration option for automatically authorizing any requests from the loopback IP address as the superuser (the one created during Harper installation). This option is enabled automatically when Harper is installed using the `dev` default config (as was instructed in the getting started guide). Thus, local installation users may make unauthenticated requests. Container based installation users must use `--network host` when running the container in order to make use of this option. And Fabric or any other remote host installations generally must authenticate all requests.

:::note
The `authentication.authorizeLocal` option should be disabled for any Harper servers that may be accessed by untrusted users from the same instance. For example, it should be disabled if you are using a local proxy, or for general server hardening.
:::

This and future learn guides will omit `Authorization` headers from any request examples. The assumption is that all local installation readers have `authorizeLocal` enabled, local container installation users are running the container with a shared network host, and Fabric users are using the UI or an authenticated HTTP client to make requests. Nonetheless, we've included the following section on how to setup Basic Authentication in case it is necessary. Most readers may skip ahead to the [First Operation API Request](#first-operation-api-request) section.

<details>
	<summary>Basic Authentication</summary>

The simplest authorization scheme is [Basic Authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Authentication#basic_authentication_scheme) which transmits credentials as username/password pairs encoded using base64. Importantly, this scheme does not encrypt credentials. If used over an insecure connection, such as HTTP, they are susceptible to being compromised. Only ever use Basic Authentication over secured connections, such as HTTPS. Even then, its better to upgrade to an encryption based authentication scheme or certificates. Harper supports many different authentication mechanisms, and they will all be covered in later Learn guides.

Use the username and password values from the previous [Install and Connect](/learn/getting-started/install-and-connect-harper) guide to generate an authorization value. The important part is to combine the `username` and `password` using a colon `:` character, encode that using base64, and then append the result to `"Basic "`. Here are some efficient methodologies:

{/* Maybe consider using Tabs here with labels like "Node.js <=v24" and ("Web" or "Winter" or "W/MCA" if defined that abbreviation earlier somehow?) */}

In Node.js v24 or earlier use the [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html) API:

```typescript
// Ensure you replace these with your installation's values
const username = 'HDB_ADMIN';
const password = 'abc123!';
const credentials = Buffer.from(`${username}:${password}`).toString('base64');
const authorizationValue = `Basic ${credentials}`;
```

For Node.js v25 or later, most web browser consoles, and any WinterTC Minimum Common API compatible runtime use the [`Uint8Array.prototype.toBase64()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/toBase64) API:

```typescript
// Ensure you replace these with your installation's values
const username = 'HDB_ADMIN';
const password = 'abc123!';
const credentials = new TextEncoder().encode(`${username}:${password}`).toBase64();
const authorizationValue = `Basic ${credentials}`;
```

> Both of these options are preferred over [`btoa()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/btoa) do to its limitation to Latin-1 character set.

And finally, you would use the `authorizationValue` as the value for the `Authorization` header such as:

```typescript
fetch('/', {
	// ...
	headers: {
		Authorization: authorizationValue,
	},
	// ...
});
```

</details>

### First Operations API Request

There are many great operations to chose from, but to get started, lets try the `get_status` operation.

:::note
All `operation` values will be in snake*case; all lowercase and underscores `*` in-place of spaces.
:::

First, ensure Harper is running (refer to the previous guide if you need a quick refresher). Then, using your HTTP client of choice, create a POST request to your running Harper instance with `Content-Type: application/json` header, and a JSON body containing `{ "operation": "get_status" }`.

> Fabric users, remember to replace `http://localhost` with your Fabric instance URL, and include an authorization header.

<Tabs>
  <TabItem value="curl">

```bash
curl -s 'http://localhost:9925/' \
	-X POST \
	-H "Content-Type: application/json" \
	-d '{ "operation": "get_status" }'
```

You may also include `| jq` here to render the output as JSON.

  </TabItem>
  <TabItem value="fetch">

```typescript
const response = await fetch('http://localhost:9925/', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json',
	},
	body: JSON.stringify({
		operation: 'get_status',
	}),
});
const data = await response.json();
console.log(data);
```

  </TabItem>

</Tabs>

This operation returns a JSON object with three top-level properties: `restartRequired`, `systemStatus`, and `componentStatus`.

The `restartRequired` property is a mechanism for Harper plugins to indicate they require a restart for some changes to take effect (more on this later).

The other two properties are lists containing status objects corresponding to different parts of Harper. These should all read `"status": "healthy"` right now, and you may recognize some of the `"name"` and `"componentName"` fields as they correspond to Harper's built-in subsystems (such as `"http"`, `"threads"`, and `"authentication"`).

### More with Operations API

The Operations API is mainly intended to be used for system management purposes. It does have the ability to do data management (create/modify/query databases, tables, and records), Harper has released significantly more ergonomic and performant methods instead.

Harper keeps a reference of all operations in the Operations API reference documentation, but here a few more you can try immediately: `user_info`, `read_log`, and `describe_all`.

For `describe_all` to work, ensure that you are still running the Harper application you created in the previous guide. If you need to, checkout the [`02-rest-api`](https://github.com/HarperFast/create-your-first-application/tree/02-rest-api) branch of the `HarperFast/create-your-first-application` repository to ensure you have the necessary application files for this example.

You should see a JSON object with a top-level property `"data"`. This operation returns a map of all databases and tables. The `"data"` is the default database in Harper. Within that object, there should be a `"Dog"` key. This is the table you defined with `graphqlSchema` in the previous guide.

The entire JSON response should look something like this:

```json
{
	"data": {
		"Dog": {
			"schema": "data",
			"name": "Dog",
			"hash_attribute": "id",
			"audit": true,
			"schema_defined": true,
			"attributes": [
				{
					"attribute": "id",
					"type": "ID",
					"is_primary_key": true
				},
				{
					"attribute": "name",
					"type": "String"
				},
				{
					"attribute": "breed",
					"type": "String"
				},
				{
					"attribute": "age",
					"type": "Int"
				}
			],
			"db_size": 212992,
			"sources": [],
			"record_count": 1,
			"table_size": 16384,
			"db_audit_size": 16384
		}
	}
}
```

Now lets keep drilling down in specificity by using the `describe_database` and then the `describe_table` operations. The difference this time is that these operations require additional properties.

For `describe_database`, you can specify `"database": "data"`. The entire request body would look something like this:

```json
{
	"operation": "describe_database",
	"database": "data"
}
```

The response this time should omit the top-level `"data"` key, and instead be just an object containing `"Dog"` (the singular table defined in the `data` database so far).

And for `describe_table`, you would specify both `"database": "data"` and `"table": "Dog"`,

```json
{
	"operation": "describe_database",
	"database": "data",
	"table": "Dog"
}
```

Now there is yet another way to get information about the `Dog` table; with the REST interface!

Create a `GET` request to `http://localhost:9926/Dog` and its important that you omit any trailing forward slash `/`, this request should return a slightly different JSON object describing the `Dog` table.

<Tabs>
  <TabItem value="curl">

```bash
curl -s 'http://localhost:9926/Dog' | jq
```

  </TabItem>
  <TabItem value="fetch">

```typescript
const response = await fetch('http://localhost:9926/Dog');
const data = await response.json();
console.log(data);
```

  </TabItem>

</Tabs>

Expected result:

```json
{
	"records": "./",
	"name": "Dog",
	"database": "data",
	"auditSize": 3,
	"attributes": [
		{
			"type": "ID",
			"name": "id",
			"isPrimaryKey": true,
			"attribute": "id"
		},
		{
			"type": "String",
			"name": "name",
			"attribute": "name"
		},
		{
			"type": "String",
			"name": "breed",
			"attribute": "breed"
		},
		{
			"type": "Int",
			"name": "age",
			"attribute": "age"
		}
	]
}
```

All in all, the Operations API is fundamental tool for managing and introspecting your Harper instance. We'll cover more operations throughout the Learn guides.

## The Harper CLI

So far you've only used the Harper CLI to run Harper itself, but it can do so much more than that!

In previous guides we demonstrated how to use the `harper` and `harper dev` commands to run Harper; with the later automatically restarting threads on application changes. There are a few more ways to manage a Harper instance using the CLI.

- `harper run <path>` is an alias for the default `harper` command. These commands run Harper in the current process
- `harper start` will start Harper in a background process
- `harper stop` command will gracefully shutdown Harper
- `harper restart` will restart the main process and all threads (different than the thread-only restart from the `dev` command)
- `harper status` displays the status of the process including the PID

There are a few more commands not listed here (check out the [CLI reference]() if you're interested), and there is one more fun trick with the CLI.

Certain operations from the Operations API are available as CLI commands! They follow the convention: `harper <operation> <param>=<value>`, and by return YAML by default. You can always pass `json=true` to see the result in JSON instead.

We'll dive deeper in the CLI operations later for the purpose of deploying and managing your application, but for now, try out some of the operations you've already learned. Don't forget that you can append `json=true` and `| jq` to get nicely formatted JSON output.

```bash
harper get_status
harper describe_all
harper describe_database database=data
harper describe_table database=data table=Dog
```

## Expanding your Harper Application with custom Resources

If you're following along from getting started, you should have a basic Harper application running containing a `schema.graphql` and `config.yaml` files defining a simple `Dog` table and REST endpoint. Lets expand on this example while also exploring more of Harper's lifecycle and application development capabilities.

:::note
If you want to ensure you're application code is at the right starting point, checkout the [`02-rest-api`](https://github.com/HarperFast/create-your-first-application/tree/02-rest-api) branch of the `HarperFast/create-your-first-application` repository.
:::

Create a new file `resources.js` within your Harper application; here we are going to define custom Resources.

**Resources** are the mechanism for defining custom functionality in your Harper application. This gives you tremendous flexibility and control over how data is accessed and modified in Harper. The corresponding Resource API is a unified API for modeling different data sources within Harper as JavaScript classes. Generally, this is where the core business logic of your application lives. Database tables (the ones defined by `graphqlSchema` entries) are `Resource` classes, and so extending the function of a table is as simple as extending their class.

Resource classes have methods that correspond to standard HTTP/REST methods, like `get`, `post`, `patch`, and `put` to implement specific handling for any of these methods (for tables they all have default implementations). Furthermore, by simply `export` 'ing a resource class, Harper will generate REST API endpoints for it just like the `@export` directive did in `graphqlSchema`. The Resource API is quite powerful, and we'll dive into different aspects throughout future Learn guides, but for now lets start with a trivial example extending the existing `Dog` table that already exists in your application.

Inside of `resources.js` add the following code for defining a `DogWithHumanAge` custom resource:

```javascript
// Fun fact, the 7:1 ratio is a misconception
// https://www.akc.org/expert-advice/health/how-to-calculate-dog-years-to-human-years/
function calculateHumanAge(dogAge) {
	if (dogAge === 1) {
		return 15;
	} else if (dogAge === 2) {
		return 24;
	} else {
		return 24 + 5 * (dogAge - 2);
	}
}

export class DogWithHumanAge extends tables.Dog {
	static loadAsInstance = false;
	async get(target) {
		const dogRecord = await super.get(target);

		return {
			...dogRecord,
			humanAge: calculateHumanAge(dogRecord.age),
		};
	}
}
```

Then open `config.yaml` and add the `jsResource` plugin:

```yaml
# Harper application configuration
graphqlSchema:
  files: 'schema.graphql'
jsResource:
  files: 'resources.js'
rest: true
```

Ensure Harper has restarted (automatically in `dev` mode or by manually starting/stopping it), and then prepare to query the new resource. In the getting started guide we created a singular dog record with an id of `001`. Create a `GET` request to `/DogWithHumanAge/001` and display the resulting JSON:

<Tabs groupId="http-client">
  <TabItem value="curl">

```bash
curl -s 'http://localhost:9926/DogWithHumanAge/001' | jq
```

  </TabItem>
  <TabItem value="fetch">

```typescript
const response = await fetch('http://localhost:9926/DogWithHumanAge/001');
const dog = await response.json();
console.log(dog);
```

  </TabItem>
</Tabs>

The resulting JSON object should look similar to the original `Dog/001` entry, except this time there is a new property `humanAge`.

```json
{
	"name": "Harper",
	"breed": "Black Labrador / Chow Mix",
	"age": 5,
	"id": "001",
	"humanAge": 39
}
```

Notably, did you see how we were able to use the `001` id with the new resource immediately? And it was able to derive the underlying `Dog` record? Lets take a closer look at the custom resource implementation:

```javascript
export class DogWithHumanAge extends tables.Dog {
	// ...
}
```

The `DogWithHumanAge` class extends from `tables.Dog`. The `tables` reference is a global added by Harper that is a map of all tables within the instance, such as the ones defined by `graphqlSchema`. The `export` keyword is used here to instruct Harper to automatically generated a REST API endpoint for the custom resource.

```javascript
export class DogWithHumanAge extends tables.Dog {
	static loadAsInstance = false;
	async get(target) {
		// ...
	}
}
```

The `static loadAsInstance = false;` line established that the Resource instances will not be bound to a specific record. Instead instances represent the whole table, capturing the context and current transactional state.

```javascript
export class DogWithHumanAge extends tables.Dog {
	static loadAsInstance = false;
	async get(target) {
		const dogRecord = await super.get(target);

		return {
			...dogRecord,
			humanAge: calculateHumanAge(dogRecord.age),
		};
	}
}
```

Thus, the `super` part of `const dogRecord = await super.get(target);` refers to the original `tables.Dog`. By passing through the `target` object to `super.get(target)`, we are querying the original `Dog` table defined by `graphqlSchema`. The `dogRecord` instance returned here corresponds to whatever the request `/<id>` portion specified.

The rest of the `get()` method returns a new object with a copy of `dogRecord` and a newly computed `humanAge` field.

The `dogRecord` isn't just a plain JSON object; it has its own set of methods including comprehensive getters and setters. However, Harper does make all the defined properties available as enumerable properties so by using the `...` spread operator, you can easily copy all of the relevant properties of the `dogRecord` instance.

Now if you perhaps tried to use a query string selector, like `GET /DogWithHumanAge/?age=5`, this `get()` method implementation can't quite handle it yet; but this will be covered soon!

For now, celebrate that you've successfully implemented your first custom resource!

## Debugging Harper Applications

Now that your Harper application is actually executing some custom logic; lets learn how to efficiently debug your code.

Thinking back to the Harper architecture earlier in this guide, we detailed that Harper runs as a singular main process and uses worker threads for parallelization. Furthermore, we mentioned that where exactly Harper runs your application code is a bit dynamic. Applications are executed by plugins and extensions. Plugins will only ever run on worker threads, but some old extensions still execute on the main thread. Harper is hard at work converting all of the built-in extensions to the new plugin API, but it is still a work in progress. For example, the `graphqlSchema` and `rest` plugins you used are actually still extensions. However, `jsResource` has been converted to the new plugin API.

Harper provides the ability to launch a proper debugger as part of the Harper process; which you can connect to from any debugger tool such as your browser or IDE. This will let you properly debug your application code, particularly the custom code you implemented in `resources.js` with `jsResource` plugin.

Harper v4 (the current version everyone uses) ships as a built and minified package, so debugging the Harper source may be confusing; you generally will only want to debug your custom code. However, in the near future, as Harper v5 is released using our new open source core, you will be able to debug Harper's core too!

Before getting started, lets use the Operations API to inspect how Harper is currently configured. Lets use the `get_configuration` operation. We are looking for the `"threads"` part of the configuration object in particular.

<Tabs>
  <TabItem value="CLI">

```bash
harper get_configuration json=true | jq .'threads'
```

  </TabItem>
  <TabItem value="curl">

```bash
curl -s 'http://localhost:9925/' \
	-X POST \
	-H "Content-Type: application/json" \
	-d '{ "operation": "get_configuration" }' | jq .'threads'
```

  </TabItem>
  <TabItem value="fetch">

```typescript
const response = await fetch('http://localhost:9925/', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json',
	},
	body: JSON.stringify({
		operation: 'get_configuration',
	}),
});
const data = await response.json();
console.log(data.threads);
```

  </TabItem>
</Tabs>

The result should contain two properties, `count` and `debug`. With the development default config these configuration properties should have the values:

```json
{
	"count": 1,
	"debug": true
}
```

If you values aren't the same, then use this as an opportunity to try using the `set_configuration` operation! You'll need to specify the nested property as snake_case, so to set `debug: true`, you would specify: `harper set_configuration threads_debug=true`. Don't forget to restart the entire Harper process after making configuration changes.

If you look closely at your Harper output, you should see a line `Debugger listening on` followed by a WebSocket URL (starts with `ws://`).

Using a debugger of your choice, attach to this debug process.

Now set a breakpoint somewhere in `resources.js` such as the last return statement of `calculateHumanAge()`.

Then run the `GET /DogWithHumanAge/001` query from earlier and watch as your debugger breaks in your custom code!

Don't forget to _continue_ the process using the debugger to let the request complete.

:::note
When using the debugger, and breaking on application code for too long, particularly in a custom resource, you may see log lines such as:

```
[http/1] [warn]: JavaScript execution has taken too long and is not allowing proper event queue cycling, consider using 'await new Promise(setImmediate)' in code that will execute for a long duration
```

:::

You can disconnect the debugger and resume using Harper as usual.

## Logging with Harper Logger

Harper comes with a built-in logger. It is what powers the `harper` CLI output and throughout building your first application and trying some operations, you've likely seen many additional lines in your terminal output. You may have even tried the `read_log` operation too.

The logger is a very fundamental piece to application development. Not only does it a serve a crucial purpose at runtime for understanding how your application is running, but it can be a very useful development tool too.

Harper's logger is available as a global `logger` API. It has methods for each log level, and some additional utilities too.

The available log levels (in hierarchical order) are:

```
trace
debug
info
warn
error
fatal
notify
```

The main logger is configured at the top-level of the configuration object. Try using the operations API to view your instance's current logging configuration.

The `logger` configuration object has a lot to it, but the most important fields for application _development_ (don't worry, we'll discuss running applications in production in another guide) are `level`, `console`, and `stdStreams`.

For example, `level` is defaulted to `info` in `dev` mode. This means that all logs from `info` to `notify` levels will be created by default. If you want to see additional levels, use `set_configuration` to change the log level (remember to use snake_case to specify the configuration property, ex `logging_level=debug`).

The best way to conceptualize Harper's logger is that its primary function is to output structure logs to a specified log file(s). By default this is `<root_path>/logs/hdb.log`. Now the `stdStreams` configuration option is what instructs the logger to _also_ log Harper logs to the standard output and error streams (aka `stdout` and `stderr`). Furthermore, the `console` option instructs Harper to forward `Console` API logs (aka `console.log()`) to the log file.

In general, Harper recommends you always use the Harper logger API, even for debugging and developing applications. But support for the `Console` API will always exist since we cannot dictate how downstream modules may operate.

Lets quickly practice creating a log in the custom resources code.

Add a `logger.info()` line anywhere in `resources.js`, such within the `get()` method:

```javascript
// ...
export class DogWithHumanAge extends tables.Dog {
	// ...
	async get(target) {
		logger.debug('Hello from inside DogWithHumanAge!');
		// ...
	}
}
```

Ensure Harper restarts and then execute the `GET /DogWithHumanAge/001` query again.

You should see:

```
[http/1] [info]: Hello from inside DogWithHumanAge!
```

We'll cover logs more in depth in a later guide about running your Harper app in production.

## What You've Accomplished

This guide started off with a deep dive into Harper's component architecture and differentiating applications from plugins. You learned how to use Harper's Operations API for system management, and learned some new CLI commands too. You got your first taste of Harper's Resource API and implemented your first custom endpoint. We'll be using this API a lot more throughout later guides. Finally, you learned how to use a debugger with your Harper application and how to use Harper's built-in logger too.

At this point, you should confident to start tinkering with your own ideas for a Harper application. In the next guide we'll be exploring more of Harper's Resource API, exploring more schema directives, and diving deeper into what Harper applications are really capable of.

## Additional Resources

TODO
